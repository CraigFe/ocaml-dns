<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Dns_certify (dns-certify.Dns_certify)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">dns-certify</a> &#x00BB; Dns_certify</nav><h1>Module <code>Dns_certify</code></h1></header><dl><dt class="spec value" id="val-letsencrypt_name"><a href="#val-letsencrypt_name" class="anchor"></a><code><span class="keyword">val</span> letsencrypt_name : Domain_name.t <span>&#45;&gt;</span> (Domain_name.t, [&gt; `Msg of string ]) Stdlib.result</code></dt><dd><p><code>letsencrypt_name host</code> is the service name at which we store let's encrypt certificates for the <code>host</code>.</p></dd></dl><dl><dt class="spec type" id="type-u_err"><a href="#type-u_err" class="anchor"></a><code><span class="keyword">type</span> u_err</code> = <code>[ </code><table class="variant"><tr id="type-u_err.Tsig" class="anchored"><td class="def constructor"><a href="#type-u_err.Tsig" class="anchor"></a><code>| </code><code>`Tsig <span class="keyword">of</span> <a href="../../dns-tsig/Dns_tsig/index.html#type-e">Dns_tsig.e</a></code></td></tr><tr id="type-u_err.Bad_reply" class="anchored"><td class="def constructor"><a href="#type-u_err.Bad_reply" class="anchor"></a><code>| </code><code>`Bad_reply <span class="keyword">of</span> <a href="../../dns/Dns/Packet/index.html#type-mismatch">Dns.Packet.mismatch</a> * <a href="../../dns/Dns/Packet/index.html#type-t">Dns.Packet.t</a></code></td></tr><tr id="type-u_err.Unexpected_reply" class="anchored"><td class="def constructor"><a href="#type-u_err.Unexpected_reply" class="anchor"></a><code>| </code><code>`Unexpected_reply <span class="keyword">of</span> <a href="../../dns/Dns/Packet/index.html#type-reply">Dns.Packet.reply</a></code></td></tr></table><code> ]</code></dt><dd><p>The type of update errors.</p></dd></dl><dl><dt class="spec value" id="val-pp_u_err"><a href="#val-pp_u_err" class="anchor"></a><code><span class="keyword">val</span> pp_u_err : <a href="index.html#type-u_err">u_err</a> Fmt.t</code></dt><dd><p><code>pp_u_err ppf u</code> pretty-prints <code>u</code> on <code>ppf</code>.</p></dd></dl><dl><dt class="spec value" id="val-nsupdate"><a href="#val-nsupdate" class="anchor"></a><code><span class="keyword">val</span> nsupdate : (int <span>&#45;&gt;</span> Cstruct.t) <span>&#45;&gt;</span> (unit <span>&#45;&gt;</span> Ptime.t) <span>&#45;&gt;</span> host:Domain_name.t <span>&#45;&gt;</span> keyname:Domain_name.t <span>&#45;&gt;</span> zone:Domain_name.t <span>&#45;&gt;</span> <a href="../../dns/Dns/Dnskey/index.html#type-t">Dns.Dnskey.t</a> <span>&#45;&gt;</span> X509.CA.signing_request <span>&#45;&gt;</span> (Cstruct.t * (Cstruct.t <span>&#45;&gt;</span> (unit, [&gt; <a href="index.html#type-u_err">u_err</a> ]) Stdlib.result), [&gt; `Msg of string ]) Stdlib.result</code></dt><dd><p><code>nsupdate rng now ~host ~keyname ~zone dnskey csr</code> is a buffer with a DNS update that removes all TLSA records from the given <code>host</code>, and adds a single TLSA record containing the certificate signing request. It also returns a function which decodes a given answer, checks it to be a valid reply, and returns either unit or an error. The outgoing packet is signed with the provided <code>dnskey</code>, the answer is checked to be signed by the same key. If the sign operation fails, <code>nsupdate</code> returns an error.</p></dd></dl><dl><dt class="spec type" id="type-q_err"><a href="#type-q_err" class="anchor"></a><code><span class="keyword">type</span> q_err</code> = <code>[ </code><table class="variant"><tr id="type-q_err.Decode" class="anchored"><td class="def constructor"><a href="#type-q_err.Decode" class="anchor"></a><code>| </code><code>`Decode <span class="keyword">of</span> <a href="../../dns/Dns/Packet/index.html#type-err">Dns.Packet.err</a></code></td></tr><tr id="type-q_err.Bad_reply" class="anchored"><td class="def constructor"><a href="#type-q_err.Bad_reply" class="anchor"></a><code>| </code><code>`Bad_reply <span class="keyword">of</span> <a href="../../dns/Dns/Packet/index.html#type-mismatch">Dns.Packet.mismatch</a> * <a href="../../dns/Dns/Packet/index.html#type-t">Dns.Packet.t</a></code></td></tr><tr id="type-q_err.Unexpected_reply" class="anchored"><td class="def constructor"><a href="#type-q_err.Unexpected_reply" class="anchor"></a><code>| </code><code>`Unexpected_reply <span class="keyword">of</span> <a href="../../dns/Dns/Packet/index.html#type-reply">Dns.Packet.reply</a></code></td></tr><tr id="type-q_err.No_tlsa" class="anchored"><td class="def constructor"><a href="#type-q_err.No_tlsa" class="anchor"></a><code>| </code><code>`No_tlsa</code></td></tr></table><code> ]</code></dt><dd><p>The type for query errors.</p></dd></dl><dl><dt class="spec value" id="val-pp_q_err"><a href="#val-pp_q_err" class="anchor"></a><code><span class="keyword">val</span> pp_q_err : <a href="index.html#type-q_err">q_err</a> Fmt.t</code></dt><dd><p><code>pp_q_err ppf q</code> pretty-prints <code>q</code> on <code>ppf</code>.</p></dd></dl><dl><dt class="spec value" id="val-query"><a href="#val-query" class="anchor"></a><code><span class="keyword">val</span> query : (int <span>&#45;&gt;</span> Cstruct.t) <span>&#45;&gt;</span> X509.public_key <span>&#45;&gt;</span> Domain_name.t <span>&#45;&gt;</span> (Cstruct.t * (Cstruct.t <span>&#45;&gt;</span> (X509.t, [&gt; <a href="index.html#type-q_err">q_err</a> ]) Stdlib.result), [&gt; `Msg of string ]) Stdlib.result</code></dt><dd><p><code>query rng pubkey name</code> is a <code>buffer</code> with a DNS TLSA query for the given <code>name</code>, and a function that decodes a given answer, either returning a X.509 certificate or an error.</p></dd></dl></div></body></html>